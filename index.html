<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paul Harris Space Invaders SE</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            width: 100%;
            max-width: 390px;
            height: 70vh;
            max-height: 844px;
        }
        #controls {
            position: absolute;
            bottom: 5px;
            width: 100%;
            max-width: 390px;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            box-sizing: border-box;
        }
        .control-btn {
            background: rgba(0, 100, 0, 0.5);
            border-radius: 8px;
            color: #004d00;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            padding: 10px;
            width: 60px;
            text-align: center;
            user-select: none;
            touch-action: manipulation;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #joystick {
            background: rgba(0, 100, 0, 0.5);
            border-radius: 8px;
            width: 120px;
            height: 60px;
            position: relative;
            user-select: none;
            touch-action: manipulation;
        }
        #joystick-knob {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #004d00;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #gameOver {
            position: absolute;
            color: red;
            font-family: 'Press Start 2P', monospace;
            font-size: 24px;
            text-align: center;
            display: none;
        }
        .glow-text {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: #0f0;
            text-align: center;
            text-shadow: 0 0 5px #0f0, 0 0 10px #0f0, 0 0 15px #0f0, 0 0 20px #00f;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="390" height="700"></canvas>
    <div id="controls">
        <div id="joystick">
            <div id="joystick-knob"></div>
        </div>
        <div id="fireBtn" class="control-btn">FIRE</div>
    </div>
    <div id="gameOver">GAME OVER</div>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                var filteredData = jsonData.filter(row => row.some(filledCell));
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
    </script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverText = document.getElementById('gameOver');
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystick-knob');
        const fireBtn = document.getElementById('fireBtn');

        // Audio setup
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let invaderSoundIndex = 0;
        const invaderFrequencies = [150, 130, 110, 90];

        function playPlayerShot() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        function playInvaderMove() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(invaderFrequencies[invaderSoundIndex], audioCtx.currentTime);
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.05);
            invaderSoundIndex = (invaderSoundIndex + 1) % 4;
        }

        function playInvaderDestroyed() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.2);
        }

        function playPlayerExplosion() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.8);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.8);
        }

        function playUfoSound() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.5);
            oscillator.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 1.0);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            return { oscillator, gain, endTime: audioCtx.currentTime + 1.0 };
        }

        function playUfoDestroyed() {
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.3);
        }

        function playGameOver() {
            const oscillator1 = audioCtx.createOscillator();
            const gain1 = audioCtx.createGain();
            oscillator1.type = 'sawtooth';
            oscillator1.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator1.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 1.2);
            gain1.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain1.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.2);
            oscillator1.connect(gain1);
            gain1.connect(audioCtx.destination);
            oscillator1.start();
            oscillator1.stop(audioCtx.currentTime + 1.2);

            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noise.buffer = buffer;
            noiseGain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.2);
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start();
            noise.stop(audioCtx.currentTime + 1.2);
        }

        // Game constants
        const GRID_SIZE = 24;
        const INVADER_ROWS = 5;
        const INVADER_COLS = 9;
        const PLAYER_SPEED = 200;
        const BULLET_SPEED = 400;
        const INVADER_SPEED = 20;
        const UFO_SPEED = 100;
        const STAR_COUNT = 30;
        const EXPLOSION_DURATION = 0.3;
        const BARRIER_COUNT = 4;
        const BARRIER_WIDTH = 36;
        const BARRIER_HEIGHT = 24;
        const BARRIER_PIXEL_SIZE = 3;

        // Game state
        let player = { x: canvas.width / 2 - 16, y: canvas.height - 80, width: 24, height: 12 };
        let bullets = [];
        let invaders = [];
        let barriers = [];
        let explosions = [];
        let ufo = null;
        let ufoSound = null;
        let stars = [];
        let score = 0;
        let level = 1;
        let lives = 3;
        let gameOver = false;
        let lastTime = 0;
        let invaderDirection = 1;
        let invaderStepTime = 0.5;
        let lastStepTime = 0;
        let ufoSpawnTime = 0;
        let ufoInterval = Math.random() * 5 + 10;

        // Sprite data
        const invaderSprites = [
            [
                [0,0,1,0,0,0,1,0,0],
                [0,0,0,1,0,1,0,0,0],
                [0,0,1,1,1,1,1,0,0],
                [0,1,1,0,1,0,1,1,0],
                [1,1,1,1,1,1,1,1,1],
                [1,0,1,1,1,1,1,0,1],
                [1,0,1,0,0,0,1,0,1]
            ],
            [
                [0,0,1,0,0,0,1,0,0],
                [1,0,0,1,0,1,0,0,1],
                [1,0,1,1,1,1,1,0,1],
                [1,1,1,0,1,0,1,1,1],
                [1,1,1,1,1,1,1,1,1],
                [0,1,1,1,1,1,1,1,0],
                [0,0,1,0,0,0,1,0,0]
            ]
        ];
        const invaderTypes = [
            { sprite: invaderSprites, points: 10, color: '#0f0' },
            { sprite: [[
                [0,1,1,0,0,1,1,0,0],
                [1,1,1,1,0,1,1,1,0],
                [1,1,1,1,1,1,1,1,1],
                [0,0,0,1,1,1,0,0,0],
                [0,0,1,1,0,1,1,0,0],
                [1,1,0,0,0,0,0,1,1]
            ], [
                [0,1,1,0,0,1,1,0,0],
                [1,1,1,1,0,1,1,1,0],
                [1,1,1,1,1,1,1,1,1],
                [0,0,0,1,1,1,0,0,0],
                [0,1,1,0,0,0,1,1,0],
                [0,0,1,1,0,0,1,1,0]
            ]], points: 20, color: '#ff0' },
            { sprite: [[
                [0,0,0,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,0,0,0,1,1,1],
                [0,0,0,1,1,0,1,1,0],
                [0,0,1,1,0,0,1,1,0]
            ], [
                [0,0,0,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1],
                [1,1,1,0,0,0,1,1,1],
                [0,0,1,1,0,0,0,1,1],
                [0,1,1,0,0,0,0,1,1]
            ]], points: 30, color: '#f0f' }
        ];
        const ufoSprite = [
            [0,0,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,0],
            [1,1,0,1,1,1,1,0,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [0,0,1,1,1,0,1,1,1,0]
        ];
        const playerSprite = [
            [0,0,0,0,1,0,0,0,0],
            [0,0,0,1,1,1,0,0,0],
            [0,0,0,1,1,1,0,0,0],
            [0,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1]
        ];
        const explosionSprite = [
            [0,1,1,0,1,1,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,0,0,0,0,0,0],
            [1,0,0,0,0,0,1],
            [1,0,0,0,0,0,1],
            [0,1,1,0,1,1,0]
        ];
        const barrierSprite = [
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,0,0,0,0,1,1,1,1],
            [1,1,1,0,0,0,0,0,0,1,1,1]
        ];

        // Initialize game
        function init() {
            initStars();
            initInvaders();
            initBarriers();
            document.addEventListener('keydown', handleInput);
            setupTouchControls();
            requestAnimationFrame(gameLoop);
        }

        function initStars() {
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 50 + 50
                });
            }
        }

        function initInvaders() {
            invaders = [];
            const typeIndex = Math.min(Math.floor((level - 1) / 2), invaderTypes.length - 1);
            const type = invaderTypes[typeIndex];
            for (let row = 0; row < INVADER_ROWS; row++) {
                for (let col = 0; col < INVADER_COLS; col++) {
                    invaders.push({
                        x: col * 36 + 30,
                        y: row * 24 + 180,
                        width: 24,
                        height: 24,
                        type: type,
                        frame: 0,
                        alive: true
                    });
                }
            }
            invaderStepTime = 0.5 / (1 + level * 0.1);
        }

        function initBarriers() {
            barriers = [];
            const spacing = canvas.width / (BARRIER_COUNT + 1);
            for (let i = 0; i < BARRIER_COUNT; i++) {
                const pixels = barrierSprite.map(row => [...row]); // Deep copy of barrier sprite
                barriers.push({
                    x: spacing * (i + 1) - BARRIER_WIDTH / 2,
                    y: canvas.height - 150,
                    width: BARRIER_WIDTH,
                    height: BARRIER_HEIGHT,
                    pixels: pixels
                });
            }
        }

        function handleInput(e) {
            if (gameOver && e.key === 'Enter') {
                resetGame();
                return;
            }
            if (e.key === 'ArrowLeft') player.dx = -PLAYER_SPEED;
            if (e.key === 'ArrowRight') player.dx = PLAYER_SPEED;
            if (e.key === ' ') {
                shootBullet();
                playPlayerShot();
            }
        }

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') player.dx = 0;
        });

        function setupTouchControls() {
            let touchId = null;

            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!touchId) {
                    touchId = e.changedTouches[0].identifier;
                    updateJoystick(e.changedTouches[0]);
                }
            });

            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        updateJoystick(touch);
                        break;
                    }
                }
            });

            joystick.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    if (touch.identifier === touchId) {
                        player.dx = 0;
                        touchId = null;
                        joystickKnob.style.left = '50%';
                        break;
                    }
                }
            });

            function updateJoystick(touch) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const relativeX = touch.clientX - centerX;
                const maxDistance = rect.width / 2;
                const normalized = Math.max(-1, Math.min(1, relativeX / maxDistance));
                player.dx = normalized * PLAYER_SPEED;
                const knobX = 50 + (normalized * 50);
                joystickKnob.style.left = `${knobX}%`;
            }

            fireBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                shootBullet();
                playPlayerShot();
            });
        }

        function shootBullet() {
            if (bullets.filter(b => b.player).length < 1) {
                bullets.push({
                    x: player.x + player.width / 2 - 2,
                    y: player.y,
                    width: 4,
                    height: 8,
                    dy: -BULLET_SPEED,
                    player: true
                });
            }
        }

        function damageBarrier(barrier, bulletX, bulletY) {
            const pixelW = barrier.width / barrier.pixels[0].length;
            const pixelH = barrier.height / barrier.pixels.length;
            const hitX = Math.floor((bulletX - barrier.x) / pixelW);
            const hitY = Math.floor((bulletY - barrier.y) / pixelH);

            // Damage a 3x3 area around the hit point
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const px = hitX + dx;
                    const py = hitY + dy;
                    if (px >= 0 && px < barrier.pixels[0].length && py >= 0 && py < barrier.pixels.length) {
                        barrier.pixels[py][px] = 0;
                    }
                }
            }
        }

        function checkBarrierCollision(barrier, bullet) {
            const pixelW = barrier.width / barrier.pixels[0].length;
            const pixelH = barrier.height / barrier.pixels.length;
            const bulletCenterX = bullet.x + bullet.width / 2;
            const bulletCenterY = bullet.y + (!bullet.player ? bullet.height : 0);
            if (bulletCenterX >= barrier.x && bulletCenterX < barrier.x + barrier.width &&
                bulletCenterY >= barrier.y && bulletCenterY < barrier.y + barrier.height) {
                const pixelX = Math.floor((bulletCenterX - barrier.x) / pixelW);
                const pixelY = Math.floor((bulletCenterY - barrier.y) / pixelH);
                if (pixelX >= 0 && pixelX < barrier.pixels[0].length && pixelY >= 0 && pixelY < barrier.pixels.length) {
                    if (barrier.pixels[pixelY][pixelX] === 1) {
                        damageBarrier(barrier, bulletCenterX, bulletCenterY);
                        return true; // Bullet hits intact pixel
                    }
                    return false; // Bullet passes through hole
                }
            }
            return false;
        }

        function update(deltaTime) {
            if (gameOver) return;

            // Update player
            player.x += (player.dx || 0) * deltaTime;
            player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

            // Update bullets
            bullets.forEach(bullet => {
                bullet.y += bullet.dy * deltaTime;
            });
            bullets = bullets.filter(b => b.y > 0 && b.y < canvas.height);

            // Update explosions
            explosions.forEach(explosion => {
                explosion.time += deltaTime;
            });
            explosions = explosions.filter(ex => ex.time < EXPLOSION_DURATION);

            // Update invaders
            if (performance.now() / 1000 - lastStepTime > invaderStepTime) {
                let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
                invaders.forEach(inv => {
                    if (inv.alive) {
                        minX = Math.min(minX, inv.x);
                        maxX = Math.max(maxX, inv.x + inv.width);
                        maxY = Math.max(maxY, inv.y + inv.height);
                        inv.frame = (inv.frame + 1) % 2;
                    }
                });
                if (minX < 10 || maxX > canvas.width - 10) {
                    invaderDirection *= -1;
                    invaders.forEach(inv => inv.y += 12);
                }
                invaders.forEach(inv => inv.x += invaderDirection * 12);
                playInvaderMove();
                lastStepTime = performance.now() / 1000;

                if (maxY > canvas.height - 150) {
                    gameOver = true;
                    playGameOver();
                }
            }

            // Update UFO
            ufoSpawnTime += deltaTime;
            if (!ufo && ufoSpawnTime > ufoInterval) {
                ufo = {
                    x: Math.random() < 0.5 ? -36 : canvas.width,
                    y: 100,
                    width: 36,
                    height: 12,
                    dx: Math.random() < 0.5 ? UFO_SPEED : -UFO_SPEED,
                    points: 100
                };
                ufoSound = playUfoSound();
                ufoSpawnTime = 0;
                ufoInterval = Math.random() * 5 + 10;
            }
            if (ufo) {
                ufo.x += ufo.dx * deltaTime;
                if (ufo.x < -36 || ufo.x > canvas.width + 36) {
                    ufo = null;
                    if (ufoSound) {
                        ufoSound.oscillator.stop();
                        ufoSound = null;
                    }
                } else if (ufoSound && audioCtx.currentTime > ufoSound.endTime) {
                    ufoSound.oscillator.stop();
                    ufoSound = playUfoSound();
                }
            }

            // Update stars
            stars.forEach(star => {
                star.y += star.speed * deltaTime;
                if (star.y > canvas.height) star.y -= canvas.height;
            });

            // Collision detection
            bullets.forEach(bullet => {
                let bulletHit = false;
                // Check barrier collisions
                for (let barrier of barriers) {
                    if (checkBarrierCollision(barrier, bullet)) {
                        bulletHit = true;
                        bullet.y = bullet.player ? -10 : canvas.height + 10;
                        break;
                    }
                }
                if (!bulletHit && bullet.player) {
                    invaders.forEach(inv => {
                        if (inv.alive && bullet.x < inv.x + inv.width && bullet.x + bullet.width > inv.x &&
                            bullet.y < inv.y + inv.height && bullet.y + bullet.height > inv.y) {
                            inv.alive = false;
                            bullet.y = -10;
                            score += inv.type.points;
                            explosions.push({ x: inv.x, y: inv.y, width: inv.width, height: inv.height, time: 0, color: inv.type.color });
                            playInvaderDestroyed();
                        }
                    });
                    if (ufo && bullet.x < ufo.x + ufo.width && bullet.x + bullet.width > ufo.x &&
                        bullet.y < ufo.y + ufo.height && bullet.y + bullet.height > ufo.y) {
                        const ufoX = ufo.x;
                        const ufoY = ufo.y;
                        const ufoWidth = ufo.width;
                        const ufoHeight = ufo.height;
                        ufo = null;
                        bullet.y = -10;
                        score += 100;
                        explosions.push({ x: ufoX, y: ufoY, width: ufoWidth, height: ufoHeight, time: 0, color: '#f00' });
                        if (ufoSound) {
                            ufoSound.oscillator.stop();
                            ufoSound = null;
                        }
                        playUfoDestroyed();
                    }
                }
                if (!bulletHit && !bullet.player) {
                    if (bullet.x < player.x + player.width && bullet.x + bullet.width > player.x &&
                        bullet.y < player.y + player.height && bullet.y + bullet.height > player.y) {
                        lives--;
                        bullet.y = canvas.height + 10;
                        if (lives <= 0) {
                            gameOver = true;
                            playGameOver();
                        } else {
                            playPlayerExplosion();
                        }
                    }
                }
            });

            // Check for level completion
            if (invaders.every(inv => !inv.alive)) {
                level++;
                initInvaders();
                initBarriers();
            }

            // Enemy bullets
            if (Math.random() < 0.01 * level) {
                let aliveInvaders = invaders.filter(inv => inv.alive);
                if (aliveInvaders.length > 0) {
                    let inv = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];
                    bullets.push({
                        x: inv.x + inv.width / 2 - 2,
                        y: inv.y + inv.height,
                        width: 4,
                        height: 8,
                        dy: BULLET_SPEED,
                        player: false
                    });
                }
            }
        }

        function drawSprite(ctx, sprite, x, y, width, height, color, isExplosion = false) {
            const pixelW = width / sprite[0].length;
            const pixelH = height / sprite.length;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            for (let sy = 0; sy < sprite.length; sy++) {
                for (let sx = 0; sx < sprite[0].length; sx++) {
                    if (sprite[sy][sx]) {
                        if (isExplosion) {
                            ctx.strokeRect(x + sx * pixelW, y + sy * pixelH, pixelW, pixelH);
                        } else {
                            ctx.fillRect(x + sx * pixelW, y + sy * pixelH, pixelW, pixelH);
                        }
                    }
                }
            }
        }

        function drawBarrier(ctx, barrier) {
            const pixelW = barrier.width / barrier.pixels[0].length;
            const pixelH = barrier.height / barrier.pixels.length;
            ctx.fillStyle = '#0f0';
            for (let sy = 0; sy < barrier.pixels.length; sy++) {
                for (let sx = 0; sx < barrier.pixels[0].length; sx++) {
                    if (barrier.pixels[sy][sx]) {
                        ctx.fillRect(barrier.x + sx * pixelW, barrier.y + sy * pixelH, pixelW, pixelH);
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                ctx.fillRect(star.x, star.y, 2, 2);
            });

            // Draw title and HUD
            ctx.font = '12px "Press Start 2P"';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText("Paul Harris Space Invaders SE", canvas.width / 2, 20);
            ctx.textAlign = 'left';
            ctx.fillStyle = 'white';
            ctx.fillText(`Lives: ${lives}`, 10, 60);
            ctx.fillText(`Score: ${score}`, 10, 80);
            ctx.fillText(`Level: ${level}`, 10, 100);

            // Draw barriers
            barriers.forEach(barrier => drawBarrier(ctx, barrier));

            // Draw player
            drawSprite(ctx, playerSprite, player.x, player.y, player.width, player.height, '#ff0');

            // Draw invaders
            invaders.forEach(inv => {
                if (inv.alive) {
                    drawSprite(ctx, inv.type.sprite[inv.frame], inv.x, inv.y, inv.width, inv.height, inv.type.color);
                }
            });

            // Draw UFO
            if (ufo) {
                drawSprite(ctx, ufoSprite, ufo.x, ufo.y, ufo.width, ufo.height, '#f00');
            }

            // Draw bullets
            ctx.fillStyle = 'white';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });

            // Draw explosions
            explosions.forEach(ex => {
                drawSprite(ctx, explosionSprite, ex.x, ex.y, ex.width, ex.height, ex.color, true);
            });

            // Draw game over
            if (gameOver) {
                gameOverText.style.display = 'block';
                gameOverText.style.left = `${canvas.offsetLeft + canvas.width / 2 - 80}px`;
                gameOverText.style.top = `${canvas.offsetTop + canvas.height / 2 - 24}px`;
            }
        }

        function resetGame() {
            score = 0;
            level = 1;
            lives = 3;
            gameOver = false;
            bullets = [];
            explosions = [];
            ufo = null;
            if (ufoSound) {
                ufoSound.oscillator.stop();
                ufoSound = null;
            }
            gameOverText.style.display = 'none';
            joystickKnob.style.left = '50%';
            initInvaders();
            initBarriers();
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // Resume audio context on user interaction
        document.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        });

        // Handle game over tap to reset
        document.addEventListener('touchstart', (e) => {
            if (gameOver) {
                resetGame();
            }
        });

        init();
    </script>
</body>
</html>